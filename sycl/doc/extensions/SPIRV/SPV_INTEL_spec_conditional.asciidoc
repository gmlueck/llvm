= SPV_INTEL_spec_conditional

== Name Strings

SPV_INTEL_spec_conditional

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

- Greg Lueck, Intel

== Notice

Copyright (c) 2021 Intel Corporation.  All rights reserved.

== Status

Draft

== Version

[width="40%",cols="25,25"]
|========================================
| Last Modified Date | 2021-05-18
| Revision           | 1
|========================================

== Dependencies

This extension is written against the SPIR-V Specification,
Version 1.5 Revision 5.

This extension requires SPIR-V 1.0.


== Overview

This extension introduces a way to have conditional branches in code, where the
condition is the value of a specialization constant.  Since the condition will
be know at the time when SPIR-V is compiled into native code, the conditional
code is guaranteed to be removed if the condition is false, conceptually
similar to the C++ `if constexpr` statement.


== Extension Name

To use this extension within a SPIR-V module, the following *OpExtension* must
be present in the module:

----
OpExtension "SPV_INTEL_spec_conditional"
----


== Motivation

The primary motivation for this extension is to support languages for offload
compute such as SYCL.  However, we feel this extension could also support
similar use cases for shaders and other tools that use SPIR-V.

=== Conditional code within a kernel

Offload compute languages have a need to write kernels that have conditional
code based on the value of a specialization constant.  The syntax could vary
from one language to another, but one hypothetical syntax might look like this:

```
void fancy() {
  /* use features specific to this fancy GPU */
}

void fallback() {
  /* use generic features */
}

void foo() {
  specconstexpr bool isFancyGpu = /* get value of specialization constant */;
  if specconstexpr (isFancyGpu) {
    fancy();
  }
  else {
    fallback();
  }
  specconstexpr int subGroupSize = /* get value of specialization constant */;
  if speconstexpr (subGroupSize == 8) {
    /* algorithm specific to device with sub group size of 8 */
  }
}
```

In this example, the offload kernel has two `if` statements that do something
conditionally based on the features that the target device provides.  Since
these device features may not correspond to SPIR-V "capabilities", it's more
flexible to use specialization constants for the conditions rather than relying
on some extension to SPIR-V capabilities.  The host runtime has greater
knowledge of the device features, and it can set the values of specialization
constants accordingly.

It is important that the compiler consuming the SPIR-V is guaranteed to remove
the conditional code (in the case when the condition is false) because that
code may call intrinsic functions or make use of SPIR-V capabilities that are
not available on the target device.  If the code was not removed, the SPIR-V
client compiler might fail to compile the code even if the control flow of the
kernel ensures it is never executed.

=== Entire kernels that are conditional

There are also cases when a SPIR-V module may contain entire kernels that use
features that are specific to certain devices.  When such a module is compiled
for a device that does _not_ support these features, we need a way to exclude
these kernels from the compilation.  Obviously, these kernels could not be run
on a device that does not support them, but the need to remove them prior to
compilation goes beyond the desire to optimize the compilation time.  Rather,
we need to ensure that the compilation process doesn't fail while attempting to
compile a kernel for a device that does not support its features.

The following code snippet illustrates a hypothetical, scenario:

```
void kernel1() {
  /* uses generic features */
}

[[conditional(fancy)]]
void kernel2() {
  /* uses features available only on "fancy" devices */
}
```

In this hypothetical example, the kernel `kernel2()` is decorated with a C++
attribute that associates the kernel with the specialization constant `fancy`.
The host runtime can now control whether this this kernel is compiled into the
module by setting the value of that specialization constant before compiling
the SPIR-V.

One may ask why we cannot solve this problem instead by creating two modules:
one with `kernel1()` and the other with `kernel2()`.  This is a fair criticism,
since this would also solve the problem without any extension to SPIR-V.
However, a SPIR-V extension that solves the first motivating example
(conditional code within a kernel) also provides almost everything we need for
this case too.  It is more convenient (and less engineering effort) to use the
same solution for both cases.


== High level description

As a general strategy, this extension adds new instructions that represent the
`if specconstexpr` statements in the hypothetical code snippets above as SPIR-V
control flow instructions, rather than as `#ifdef` like instructions.  We feel
this strategy makes it easier to validate SPIR-V modules that use this
extension.  At the same time, the new instructions have been designed such that
a tool can easily specialize (or partially specialize) a module with a simple
algorithm that replaces the extended instructions with normal SPIR-V control
flow instructions.  Such a tool need not understand the control flow graph of
the module.

=== Branching on specialization constants

We add three new instructions to represent control flow that is conditioned on
a specialization constant: *OpBranchSpecConstantINTEL*,
*OpBranchSpecConstantWithElseINTEL*, and *OpPhiSpecConstantINTEL*.  The first
two are similar to *OpBranchConditional* except that the condition is the
_<id>_ of a specialization constant.  They also identify a range of control
flow blocks that must be removed when the condition is false (or that must be
removed when the condition is true for *OpBranchSpecConstantWithElseINTEL*).

The *OpPhiSpecConstantINTEL* instruction is similar to *OpPhi*, except that it
is used when at least one of the merged values flows from an
*OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL* condition.

Like *OpPhi*, *OpPhiSpecConstantINTEL* has a set of parameters for every parent
block.  Each parent has three parameters: the _<id>_ of the parent block, the
_<id>_ of a variable that is defined when control flows from that parent block,
and an _<id>_ of a specialization constant that provides a condition that gates
the merged value.  The first two _<id>_ parameters have the same meaning as a
regular *OpPhi*.  The value of the condition parameter depends on whether the
parent comes from an *OpBranchSpecConstantINTEL* or
*OpBranchSpecConstantWithElseINTEL* condition:

* If the parent is a block contained by the "then" range of
  *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*, the
  condition parameter is the same specialization constant _<id>_ as the
  *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*
  instruction.

* If the parent is the _False Label_ in *OpBranchSpecConstantINTEL*, then the
  condition parameter is the _<id>_ of a specialization constant that is the
  logical negation of the specialization constant used by
  *OpBranchSpecConstantINTEL*.

* If the parent is a block contained by the "else" range of
  *OpBranchSpecConstantWithElseINTEL*, then the condition parameter is the
  _<id>_ of a specialization constant that is the logical negation of the
  specialization constant used by *OpBranchSpecConstantWithElseINTEL*.

* Otherwise, the condition parameter's value is zero.  (The value zero is not a
  legal _<id>_, so the value zero indicates that there is no associated
  specialization constant for this parent.)

This condition parameter allows tools to specialize SPIR-V more efficiently.

A tool that specializes SPIR-V can do so by looking at each of these
instructions individually, without considering their context in the control
flow graph.  Occurrences of *OpBranchSpecConstantINTEL* and
*OpBranchSpecConstantWithElseINTEL* are replaced with *OpBranch* to either the
_True Label_ or the _False Label_, according to the value of the specialization
constant.  The specializing tool is also responsible for removing either the
"then" range of blocks or the "else" range of blocks that are associated with
the *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*
instruction.  These ranges are easy to identify because they are guaranteed to
be contiguous in the SPIR-V module and the *OpBranchSpecConstantINTEL* /
*OpBranchSpecConstantWithElseINTEL* instructions provide pointers to the
ranges.

Occurrences of *OpPhiSpecConstantINTEL* are replaced with regular *OpPhi*.
When constructing the parent parameters to *OpPhi*, the specialization tool
uses the parent's condition parameter:

* If the condition parameter's value is zero, this parent has no associated
  specialization constant and the parent's other two parameters are retained
  in the *OpPhi*.  Otherwise, the parent is associated with a specialization
  constant:

* If that specialization constant's value is *true*, the parent's other two
  parameters are retained in the *OpPhi*.

* If that specialization constant's value is *false*, the parent is omitted
  from the *OpPhi*.

The following example demonstrates this process.  Consider this unspecialized
SPIR-V:

```
    %int = OpTypeInt 32 0
   %bool = OpTypeBool
   %spec = OpSpecConstantTrue %bool
%notspec = OpSpecConstantOp %bool LogicalNot %spec

  ...

    %top = OpLabel
     %10 = OpIAdd %int ....
           OpBranchSpecConstantINTEL %spec %true %true %false
   %true = OpLabel
     %11 = OpIAdd %int ....
           OpBranch %false
  %false = OpLabel
     %12 = OpPhiSpecConstantINTEL %int %notspec %10 %top %spec %11 %true

   ...
```

Specializing this code such that *%spec* is *false* yields:

```
    %int = OpTypeInt 32 0
   %bool = OpTypeBool
   %spec = OpConstantFalse %bool
%notspec = OpConstantTrue %bool

  ...

    %top = OpLabel
     %10 = OpIAdd %int ....
           OpBranch %false
  %false = OpLabel
     %12 = OpPhi %int %10 %top

   ...
```

Note that the process of specialization can sometimes lead to blocks that have
only one parent and *OpPhi* instructions that have only one parent, as shown in
the example above.  Normal optimizations in tools that consume SPIR-V can
optimize these cases, but such optimizations are not necessary for the
correctness of the specialized code.

=== Conditional capabilities, functions, types, etc.

Since the specialization process will remove blocks from the control flow graph
in some cases, it may be desirable to also remove functions that are called
only from these blocks.  Likewise, it may be desirable to remove variables,
types, or constants that are used only in these blocks.  This may be necessary
for correctness, for example, if a function that is called only from the
removed blocks uses device features or SPIR-V capabilities that are unavailable
on the device.  (See the `fancy()` function in the motivation section for an
example of this.)

To support this case, the extension adds a new *OpConditionalCapabilityINTEL*
instruction and a new *ConditionalINTEL* decoration.  If a tool that generates
SPIR-V wants to guarantee that a function, variable, type, or constant is
removed when a specialization constant has a certain value, it must use the
*ConditionalINTEL* decoration to do this.  Specializing tools have no
requirement to automatically find and remove these instructions, even if the
only reference is from blocks that the specializing tool removes.  Likewise, if
a tool that generates SPIR-V wants to express that a capability is only
required when a specialization constant has a certain value, it must use the
*OpConditionalCapabilityINTEL* instruction.

The *OpConditionalCapabilityINTEL* instruction is like *OpCapability* except it
has an _<id>_ parameter which references a specialization constant.  This
instruction adds a requirement for the capability only if that specialization
constant's value is *true*.

The *ConditionalINTEL* decoration instruction takes an _<id>_ operand that
references a specialization constant.  The decorated instruction will be
removed during specialization if that specialization constant's value is
*false*.

The specialization process is very straightforward for
*OpConditionalCapabilityINTEL*.  This instruction is either removed or replaced
with *OpCapability* depending on the value of the specialization constant.

When specializing an instruction that is decorated with *ConditionalINTEL* the
*ConditionalINTEL* decoration itself is always removed.  In addition, the
following happens if the specialization constant is *false*:

* If the decorated instruction is *OpFunction*, the function and all of its
  instructions are removed.  All decorations for the function and its
  instructions are removed.  If the *OpFunction* has an associated
  *OpEntryPoint*, that is also removed.  Any *OpName* or *OpMemberName* that
  references the *OpFunction* or any of its instructions are also removed.

* Otherwise, the decorated instruction is removed, all decorations for the
  instruction are removed, and any *OpName* or *OpMemberName* referencing the
  instruction are removed.

Tools that generate SPIR-V are responsible for ensuring that the
*ConditionalINTEL* decoration is used such that an instruction that defines an
SSA _<id>_ is never removed unless all the references to that SSA _<id>_ are
also removed regardless of the values assigned to the specialization
constants.

Since *ConditionalINTEL* may be applied to an instruction that defines a
specialization constant, there is the possibility of ambiguity.  What if
specialization constant `A` is decorated with *ConditionalINTEL*, but `A` is
also used as the _Condition_ for *OpConditionalCapabilityINTEL*,
*OpBranchSpecConstantINTEL*, *OpBranchSpecConstantWithElseINTEL*,
*OpPhiSpecConstantINTEL*, or as the _Condition_ for another *ConditionalINTEL*
decoration?  We avoid these ambiguities by making this situation illegal.
If a specialization constant _<id>_ is decorated with *ConditionalINTEL*, it
may not be used as a _Condition_ for any of these instructions or for the
_Condition_ in a *ConditionalINTEL* decoration.

=== Validation

In order to validate a module that uses this extension, we first apply the
normal validation rules assuming that either branch of
*OpBranchSpecConstantINTEL*, or *OpBranchSpecConstantWithElseINTEL* could be
taken at runtime.  This essentially means that we treat these instructions as
though they were *OpBranchConditional*, we treat *OpPhiSpecConstantINTEL* as
though it was *OpPhi*, and we treat *OpConditionalCapabilityINTEL* as though it
was *OpCapability*.  We then apply some additional validation rules to ensure
that the extension's instructions and decorations are used in a way that
results in consistent code.

These additional validation rules start by computing a specialization constant
expression `G(i)` that gates usage of each instruction `i`.  The value of
`G(i)` is computed with the following rules

* Start with `G(i) = true`.

* If the instruction resides in a "then" range of *OpBranchSpecConstantINTEL*
  or *OpBranchSpecConstantWithElseINTEL*, let `G(i) = G(i) && S` where `S` is
  the specialization constant referenced by *OpBranchSpecConstantINTEL* or
  *OpBranchSpecConstantWithElseINTEL*.

* If the instruction resides in an "else" range of
  *OpBranchSpecConstantWithElseINTEL*, let `G(i) = G(i) && !S` where `S` is the
  specialization constant referenced by *OpBranchSpecConstantWithElseINTEL*.

* If the instruction resides in an *OpFunction* that is decorated with
  *ConditionalINTEL*, let `G(i) = G(i) && S` where `S` is the specialization
  constant referenced by the *ConditionalINTEL* decoration.

* If the instruction itself is decorated with *ConditionalINTEL*, let
  `G(i) = G(i) && S` where `S` is the specialization constant referenced by the
  *ConditionalINTEL* decoration.

We then apply the following validation rules:

* If a module requires a capability `C` that can be statically checked, and if
  that capability is required only through *OpConditionalCapabilityINTEL*
  instructions, we compute the specialization constant expression `G(c)` that
  is the logical "or" of the specialization constants used by each of these
  *OpConditionalCapabilityINTEL* instructions.  We then scan through the code
  looking for instructions that use capability `C`.  For each such instruction
  `i`, validate that `G(i)` can never be true unless `G(c)` is also true.

* For each instruction `idef` that defines an SSA _<id>_, search for all other
  instructions `iuse` that use _<id>_.  Validate that each `G(iuse)` can never
  be true unless `G(idef)` is also true.

* For each block that is contained by the "then" range of
  *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*, verify
  that each parent block is also contained by that same "then" range (allowing,
  of course, that the *OpBranchSpecConstantINTEL* or
  *OpBranchSpecConstantWithElseINTEL* instruction is a parent of the first
  block in that range).

* For each block that is contained by the "else" range of
  *OpBranchSpecConstantWithElseINTEL*, verify that each parent block is also
  contained by that same "else" range (allowing, of course, that the
  *OpBranchSpecConstantWithElseINTEL* instruction is a parent of the first
  block in that range).

* For each (_Condition i_, _Variable i_, _Parent i_) triplet of
  *OpPhiSpecConstantINTEL*:
  - If _Parent i_ resides in the "then" range of *OpBranchSpecConstantINTEL* or
    *OpBranchSpecConstantWithElseINTEL*, verify that _Condition i_ is the same
    specialization constant _<id>_ as the *OpBranchSpecConstantINTEL* or
    *OpBranchSpecConstantWithElseINTEL* instruction.

  - If _Parent i_ is the _False Label_ of *OpBranchSpecConstantINTEL* or
    _Parent i_ resides in the "else" range of
    *OpBranchSpecConstantWithElseINTEL*, verify that _Condition i_ is the
    _<id>_ of a specialization constant that is the logical negation of the
    specialization constant _<id>_ used by the *OpBranchSpecConstantINTEL* or
    *OpBranchSpecConstantWithElseINTEL* instruction.

  - Otherwise, verify that _Condition i_ has the value zero.

  - If _Variable i_ is defined by a block in the "then" range of
    *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*, or if
    _Variable i_ is defined by a block in the "else" range of
    *OpBranchSpecConstantWithElseINTEL*, verify that _Parent i_ is contained by
    that same "then" or "else" range.

* For each specialization constant (*OpSpecConstantXXX*) that is decorated with
  *ConditionalINTEL*, verify that the specialization constant's _<id>_ is not
  also used as a _Condition_ for *OpConditionalCapabilityINTEL*,
  *OpBranchSpecConstantINTEL*, *OpBranchSpecConstantWithElseINTEL*,
  *OpPhiSpecConstantINTEL*, or *ConditionalINTEL*.

*TODO*: I'm looking for feedback on the validation rules that involve
comparison of abstract specialization constants such as "validate that `G(i)`
can never be true unless `G(c)` is also true".  These validations are likely
very difficult in the general case, but most cases will be very easy.  (In most
cases, I think that `G(i)` and `G(c)` will both be so simple that it will be
easy to prove whether one implies the other.)  How should the spec handle this?
Are the validation rules _requirements_ that a validation tool must perform, or
are they just rules about what SPIR-V is not valid?  If they are not
requirements, then we could leave the wording as I have it and then each
validation tool would be free to implement the validation checks as thoroughly
as it wants.


== New tokens defined by this extension

=== New capabilities

The module must declare that it uses the following capability in order to use
any of the decorations or instructions defined in the sections below.  If
declared, this capability must be unconditionally declared via *OpCapability*.
It may not be conditionally declared via *OpConditionalCapabilityINTEL*.

[cols="1,15,5",options="header",width="100%"]
|===
2+^| Capability | Implicitly Declares
| ????
| *SpecConditionalINTEL* +
Module conditionally enables code based on the value of a specialization
constant.
|
|===

=== New decorations

[cols="1,10,5,5",options="header",width="100%"]
|====
2+^| Decoration | Extra Operands | Enabling Capabilities
| ????
| *ConditionalINTEL* +
May be applied only to *OpFunction*, global (module scope) *OpVariable*, type
declarations (*OpTypeXXX*), or constant instructions (*OpConstantXXX* or
*OpSpecConstantXXX*).  Indicates that the decorated instruction must be removed
if the value of the specialization constant identified by _Condition_ is
*false*.  The _Condition_ must be a _Boolean type_ scalar.

If the decorated instruction is *OpFunction*, the function and all of the
instructions it contains are removed when the specialization constant is
*false*.  If the function has an associated *OpEntryPoint*, that is also
removed.
| _<id>_ _Condition_
|*SpecConditionalINTEL*
|====

=== New instructions

[cols="1,1,2*3",width="100%"]
|===
3+|*OpConditionalCapabilityINTEL* +
 +
Declare a capability that is conditionally used by this module, depending on
the value of a specialization constant.

The _Capability_ is used by this module only if the specialization constant
identified by _Condition_ is *true*.  The _Condition_ must be a _Boolean type_
scalar.

1+|Capability: +
*SpecConditionalINTEL*
| 3
| ????
| _<id>_ _Condition_
| _Capability_
|===

[cols="1,1,4*3",width="100%"]
|===
5+|*OpBranchSpecConstantINTEL* +
 +
If the specialization constant _Condition_ is *true*, branch to _True Label_,
otherwise branch to _False Label_.  The _Condition_ must be a _Boolean type_
scalar.

The consecutive blocks from _True Label_ to _True End_ (inclusive) are called
the "then" range of this instruction.  If the _Condition_ is *false*, this
range of blocks is removed from the module.  The module need not declare any
capabilities used by these instructions if they are removed.

No block in the "then" range may have a parent that is outside of that range,
except for the _True Label_ reference from this *OpBranchSpecConstantINTEL*
instruction.

1+|Capability: +
*SpecConditionalINTEL*
| 5
| ????
| _<id>_ _Condition_
| _<id>_ _True Label_
| _<id>_ _True End_
| _<id>_ _False Label_
|===

[cols="1,1,5*3",width="100%"]
|===
6+|*OpBranchSpecConstantWithElseINTEL* +
 +
If the specialization constant _Condition_ is *true*, branch to _True Label_,
otherwise branch to _False Label_.  The _Condition_ must be a _Boolean type_
scalar.

The consecutive blocks from _True Label_ to _True End_ (inclusive) are called
the "then" range of this instruction.  The consecutive blocks from
_False Label_ to _False End_ (inclusive) are called the "else" range of this
instruction.  If the _Condition_ is *false*, the "then" range is removed from
the module.  If the _Condition_ is *true*, the "else" range is removed from the
module.  The module need not declare any capabilities used by these
instructions if they are removed.

No block in the "then" range may have a parent that is outside of that range,
except for the _True Label_ reference from this
*OpBranchSpecConstantWithElseINTEL* instruction.  No block in the "else" range
may have a parent that is outside of that range, except for the _False Label_
reference from this *OpBranchSpecConstantWithElseINTEL* instruction.

1+|Capability: +
*SpecConditionalINTEL*
| 6
| ????
| _<id>_ _Condition_
| _<id>_ _True Label_
| _<id>_ _True End_
| _<id>_ _False Label_
| _<id>_ _False End_
|===

[cols="1a,1,3*3",width="100%"]
|===
4+|*OpPhiSpecConstantINTEL* +
 +
The SSA phi function, when one or more of the merged values is conditionally
gated by a specialization constant.  This instruction must be used instead of
*OpPhi* when any of the following are true:

* At least one of the parent blocks is the _False Label_ of an
  *OpBranchSpecConstantINTEL* instruction.

* At least one of the parent blocks is contained by the "then" range of an
  *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*
  instruction or is contained by the "else" range of an
  *OpBranchSpecConstantWithElseINTEL* instruction.

* At least one of the _Variable i_ is defined by a block that is contained by
  the "then" range of an *OpBranchSpecConstantINTEL* or
  *OpBranchSpecConstantWithElseINTEL* instruction or is defined by a block that
  is contained by the "else" range of an *OpBranchSpecConstantWithElseINTEL*
  instruction.

The result is selected based on control flow: If control reached the current
block from _Parent i_, _Result Id_ gets the value that _Variable i_ had at the
end of _Parent i_.

_Result Type_ can be any type.

Operands are a sequence of triplets: (_Cond 1_, _Variable 1_, _Parent 1_
block), (_Cond 2_, _Variable 2_, _Parent 2_ block), ...  Each _Parent i_ block
is the label of an immediate predecessor in the CFG of the current block.
There must be exactly one _Parent i_ for each parent block of the current block
in the CFG.  If _Parent i_ is reachable in the CFG and _Variable i_ is defined
in a block, that defining block must dominate _Parent i_.  All Variables must
have a type matching _Result Type_.

If _Variable i_ is defined by a block that is contained by the "then" or "else"
range of an *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*
instruction, then the associated _Parent i_ must be contained by that same
"then" or "else" range.

Each _Cond i_ is the _<id>_ of a specialization constant that gates the
associated _Variable i_ definition.  This parameter must be set as follows:

* If the _Parent i_ is the _False Label_ of an *OpBranchSpecConstantINTEL*
  instruction, _Cond i_ must be the logical negation of the specialization
  constant used by that *OpBranchSpecConstantINTEL* instruction.

* If the _Parent i_ is contained by the "then" range of an
  *OpBranchSpecConstantINTEL* or *OpBranchSpecConstantWithElseINTEL*
  instruction, _Cond i_ must be the same specialization _<id>_ used by that
  instruction.

* If the _Parent i_ is contained by the "else" range of an
  *OpBranchSpecConstantWithElseINTEL* instruction, _Cond i_ must be the logical
  negation of the specialization constant used by that
  *OpBranchSpecConstantWithElseINTEL* instruction.

* Otherwise, _Variable i_ is not gated by a specialization constant, and
  _Cond i_ must have the value zero (which is not a legal value for any
  _<id>_).

Within a block, this instruction must appear before all other instructions
aside from *OpPhi*, other instances of *OpPhiSpecConstantINTEL*, *OpLine*, or
*OpNoLine*.

1+|Capability: +
*SpecConditionalINTEL*
| 3 + variable
| ????
| _<id>_ _Result Type_
| _Result <id>_
| {_<id>_ \| _0_}, _<id>_, _<id>_, ... +
  _Cond_, _Variable_, _Parent_, ...
|===


== Modifications to the SPIR-V Specification

*TODO*: Exact wording changes for the SPIR-V specification will be proposed
once there is agreement on the semantics of this extension.


== Issues

1) The motivation section currently lists only the use cases that are important
   to SYCL.  However, there have been previous proposals for conditional code
   in SPIR-V that were motivated by shader use cases.  Should these use cases
   also be listed in the motivation section?  Some of the shader use cases
   would require small additions to this extension, so if we add those
   motivating use cases, we would also need to add a few more instructions to
   this extension proposal (instructions that would not be useful for SYCL).

2) Some of the validation rules listed above would be difficult to implement in
   the general case.  (See *TODO* comment above.)  How should this be resolved?

3) Need to assign real numbers to the new tokens, replacing the "????"
   placeholders.


== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2021-05-18|Greg Lueck|*First public draft*
|========================================
